package main

import (
	"flag"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"strings"

	"github.com/iancoleman/strcase"
	"github.com/moznion/gonstructor/internal"
	"github.com/moznion/gonstructor/internal/constructor"
	g "github.com/moznion/gowrtr/generator"
)

const (
	allArgsConstructorType = "allArgs"
	builderConstructorType = "builder"
)

type stringArrayFlag []string

func (a *stringArrayFlag) String() string {
	return strings.Join(*a, ", ")
}

func (a *stringArrayFlag) Set(item string) error {
	*a = append(*a, item)
	return nil
}

func main() {
	var typeNames stringArrayFlag
	flag.Var(&typeNames, "type", `[mandatory] A type name. It accepts this option occurs multiple times to output the generated code of the multi types into a single file. If this option is given multiple times, the "-output" option becomes mandatory.`)
	output := flag.String("output", "", `[optional] Output file name (default "srcdir/<type>_gen.go"). See also "-type" option's description.'`)
	constructorTypesStr := flag.String("constructorTypes", allArgsConstructorType, fmt.Sprintf(`[optional] comma-separated list of constructor types; it expects "%s" and "%s"`, allArgsConstructorType, builderConstructorType))
	shouldShowVersion := flag.Bool("version", false, "[optional] show the version information")
	withGetter := flag.Bool("withGetter", false, "[optional] generate a constructor along with getter functions for each field")
	initFunc := flag.String("init", "", "[optional] name of function to call on object after creating it")
	propagateInitFuncReturns := flag.Bool("propagateInitFuncReturns", false, `[optional] If this option is specified, the generated constructor propagates the return values that come from the init function specified by the "-init" option, e.g. when the init function returns an "error" value, the generated constructor returns (*YourStructType, error). Known issue: If this option is used with the multiple --type options, probably it won't be the expected result.`)

	flag.Parse()

	if *shouldShowVersion {
		internal.ShowVersion()
		return
	}

	if len(typeNames) <= 0 {
		flag.Usage()
		os.Exit(2)
	}
	if len(typeNames) >= 2 && *output == "" {
		_, _ = fmt.Fprintln(os.Stderr, `[error] if "-type" option appears two or more times, the "-output" option must be specified.`)
		flag.Usage()
		os.Exit(2)
	}

	constructorTypes, err := getConstructorTypes(*constructorTypesStr)
	if err != nil {
		log.Printf("[error] %s", err)
		flag.Usage()
		os.Exit(2)
	}

	args := flag.Args()
	if len(args) <= 0 {
		args = []string{"."}
	}

	pkg, err := internal.ParsePackage(args)
	if err != nil {
		log.Fatal(fmt.Errorf("[error] failed to parse a package: %w", err))
	}

	astFiles, err := internal.ParseFiles(pkg.GoFiles)
	if err != nil {
		log.Fatal(fmt.Errorf("[error] failed to parse a file: %w", err))
	}

	var (
		alreadyOpenedWithTruncFilesSet = map[string]bool{}
		fileHeaderGenerated            = false
		rootStmt                       = g.NewRoot()
	)
	for _, typeName := range typeNames {
		fields, err := constructor.CollectConstructorFieldsFromAST(typeName, astFiles)
		if err != nil {
			log.Fatal(fmt.Errorf("[error] failed to collect fields from files: %w", err))
		}

		var initFuncReturnTypes []string
		if *initFunc != "" {
			initFuncReturnTypes, err = constructor.CollectInitFuncReturnTypes(typeName, *initFunc, astFiles)
			if err != nil {
				log.Fatal(fmt.Errorf("[error] failed to collect the return types of the init func: %w", err))
			}
		}

		if !fileHeaderGenerated {
			rootStmt = rootStmt.AddStatements(
				g.NewComment(fmt.Sprintf(" Code generated by gonstructor %s; DO NOT EDIT.", strings.Join(os.Args[1:], " "))),
				g.NewNewline(),
				g.NewPackage(pkg.Name),
				g.NewNewline(),
			)
		}
		fileHeaderGenerated = true

		for _, constructorType := range constructorTypes {
			var constructorGenerator constructor.Generator
			switch constructorType {
			case allArgsConstructorType:
				constructorGenerator = &constructor.AllArgsConstructorGenerator{
					TypeName:                 typeName,
					Fields:                   fields,
					InitFunc:                 *initFunc,
					InitFuncReturnTypes:      initFuncReturnTypes,
					PropagateInitFuncReturns: *propagateInitFuncReturns,
				}

			case builderConstructorType:
				constructorGenerator = &constructor.BuilderGenerator{
					TypeName:                 typeName,
					Fields:                   fields,
					InitFunc:                 *initFunc,
					InitFuncReturnTypes:      initFuncReturnTypes,
					PropagateInitFuncReturns: *propagateInitFuncReturns,
				}

			default:
				// unreachable, just in case
				log.Fatalf("[error] unexpected constructor type has come [given=%s]", constructorType)
			}

			rootStmt = rootStmt.AddStatements(constructorGenerator.Generate(0))
		}

		if *withGetter {
			rootStmt = rootStmt.AddStatements(internal.GenerateGetters(typeName, fields))
		}
	}

	code, err := rootStmt.Goimports().EnableSyntaxChecking().Generate(0)
	if err != nil {
		log.Fatal(fmt.Errorf("[error] failed to generate code: %w", err))
	}

	err = func() error {
		fileName := getFilenameToGenerate(typeNames[0], *output, args)

		fileOpenFlag := os.O_APPEND | os.O_WRONLY | os.O_CREATE
		if !alreadyOpenedWithTruncFilesSet[fileName] {
			// truncate and make a blank file
			fileOpenFlag = os.O_TRUNC | os.O_WRONLY | os.O_CREATE
		}

		f, err := os.OpenFile(fileName, fileOpenFlag, 0644)
		if err != nil {
			return fmt.Errorf("[error] failed open a file to output the generated code: %w", err)
		}

		defer f.Close()

		alreadyOpenedWithTruncFilesSet[fileName] = true

		_, err = f.WriteString(code)
		if err != nil {
			return fmt.Errorf("[error] failed output generated code to a file: %w", err)
		}

		return nil
	}()
	if err != nil {
		log.Fatal(err)
	}
}

func getConstructorTypes(constructorTypes string) ([]string, error) {
	typs := strings.Split(constructorTypes, ",")
	for _, typ := range typs {
		if typ != allArgsConstructorType && typ != builderConstructorType {
			return nil, fmt.Errorf("unexpected constructor type has come [given=%s]", typ)
		}
	}
	return typs, nil
}

func isDirectory(name string) bool {
	info, err := os.Stat(name)
	if err != nil {
		log.Fatal(err)
	}
	return info.IsDir()
}

func getFilenameToGenerate(typeName string, output string, args []string) string {
	if output != "" {
		return output
	}

	var dir string
	if len(args) == 1 && isDirectory(args[0]) {
		dir = args[0]
	} else {
		dir = filepath.Dir(args[0])
	}
	return fmt.Sprintf("%s/%s_gen.go", dir, strcase.ToSnake(typeName))
}
